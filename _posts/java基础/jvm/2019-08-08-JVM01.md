---
layout:     post
title:      JVM
subtitle:   JVM之堆入门
date:       2019-08-08
author:     程序猿小哈
header-img: img/tag-bg.jpg
catalog: 	true
tags:
    - java
    - JVM
---
# JVM 第一课--> 堆

### 什么是JVM
``
JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。使用JVM,java实现一次编译,全环境运行
``

#### 堆
```
1. 存储的全部是对象，每个对象都包含一个与之对应的class的信息。(class的目的是得到操作指令) 
2. jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身,GC回收机制会处理对象
3. 可以设置固定大小
4. 可以设置动态扩容  
5. 异常:outofMemoryError
```

#### 以HotSpot为例

![JVM运行时数据区](/postImg/JVM04.png "")

`年轻代 NEW`
1. Eden Space(heap): 内存最初从这个线程池分配给大部分对象.
2. Survivor Space (heap): 用于保存在eden space内存池中经过垃圾回收后没有被回收的对象。
`老年代 OLD`
3. Tenured Generation (heap): 用于保持已经在survivor space内存池中存在了一段时间的对象.
`永久代 java8去除`
4. Permanent Generation (non-heap)  保存虚拟机自己的静态(reflective)数据，例如类（class）和方法（method）对象。Java虚拟机共享这些类数据。这个区域被分割为只读的和只写的。

5.Code Cache (non-heap) HotSpot Java虚拟机包括一个用于编译和保存本地代码（native code）的内存，叫做“代码缓存区”（code cache）。

1.2属于堆内存,jvm启动参数(-Xmx:3G)分配指定的内存,Perm不属于堆内存,由虚拟机直接分配,可以通过-XX:PermSize -XX:MaxPermSize等参数调整大小


年轻代分为`Eden Space/Survivor Space`. `Eden Space`存放JVM刚创建的对象. 在GC回收后,会将剩下的对象放入`Survivor Space`.`Survivor Space`,又有两个区域Survivor1和Survivor2(两个区域可以通过设置参数来改变大小比例).两个区域内的对象经过多次GC后存活的对象会进入老年区.对象在老年区,再次GC后最终进入永久区.如下图:

 ![对象流转图](/postImg/JVM05.png "")

在年轻代的GC(Minor GC):年轻代有两个区域,在不同的区域使用的GC算法并不相同,分为`标记清除/标记复制`.
在老年代的GC(Major GC):老年代只有一个区域,GC算法为`标记压缩`.

> 标记擦除:标记对象,删除无效对象

> 标记复制:标记对象,复制有效的到复制区(所以S区分为两块用于复制)

> 标记压缩:标记对象,压缩删除无效对象,可以整理内存

那么`标记`是怎么做的呢？ 这就引入了计算是否标记的两种计算方式

1. `引用计数法`
这个算法的实现是，给对象中添加一个引用计数器，每当一个地方引用这个对象时，计数器值+1；当引用失效时，计数器值-1。任何时刻计数值为0的对象就是不可能再被使用的。这种算法使用场景很多，但是，Java中却没有使用这种算法，因为这种算法很难解决对象之间相互引用的情况

那么什么样的引用是有效引用呢?
```
1. 强引用:
   代码中普遍存在的类似"Object obj = new Object()"这类的引用，`只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象`。
2. 软引用:
   `描述有些还有用但并非必需的对象。在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围进行二次回收`。如果这次回收还没有足够的内存，才会抛出内存溢出异常。Java中的类SoftReference表示软引用。
3. 弱引用:
   `描述非必需对象。被弱引用关联的对象只能生存到下一次垃圾回收之前，垃圾收集器工作之后，无论当前内存是否足够，都会回收掉只被弱引用关联的对象`。Java中的类WeakReference表示弱引用。
4. 虚引用:
   `这个引用存在的唯一目的就是在这个对象被收集器回收时收到一个系统通知，被虚引用关联的对象，和其生存时间完全没关系`。Java中的类PhantomReference表示虚引用。
```

 ![4种引用](/postImg/JVM06.png "")

2. `可达性分析法`

```
这个算法的基本思想是通过一系列称为“GC Roots”的对象作为起始点，从这些节点向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链（即GC Roots到对象不可达）时，则证明此对象是不可用的。
那么问题又来了，如何选取GCRoots对象呢？在Java语言中，可以作为GCRoots的对象包括下面几种：
(1). 虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。
(2). 方法区中的类静态属性引用的对象。
(3). 方法区中常量引用的对象。
(4). 本地方法栈中JNI(Native方法)引用的对象。
```

 ![可达性分析法](/postImg/JVM07.png "")























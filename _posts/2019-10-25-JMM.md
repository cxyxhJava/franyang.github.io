---
layout:     post
title:      JMM
subtitle:   JAVA内存模型
date:       2019-10-24
author:     程序猿小哈
header-img: img/db.jpeg
catalog: 	true
tags:
    - java基础
---

# JAVA内存模型(JMM)

## 什么是JAVA内存模型
Java内存模型（Java Memory Model ,JMM）就是一种`符合内存模型规范`、`屏蔽了各种硬件和操作系统的访问差异`、保证了Java程序在各种平台下`对内存的访问都能保证效果一致`的`机制及规范`。


### 内存模型(Memory Model)
在了解JAVA内存模型之前让我们先来了解一下我们为什么需要内存模型.

#### 为什么要有内存模型

我们都知道,计算机的每条指令是在CPU中执行的,而数据是存放在主存(计算器物理内存).计算机初期CPU的计算速率和内存读取写入数据的速度差不多,相安无事.但是随着CPU技术的高速发展,执行速度越来越快,内存数据读取写入跟不上CPU的处理速度,导致CPU每次操作都要耗费很长的时间等待数据获取.为了处理内存读取数据速率导致的性能瓶颈,在CPU和内存之间引入了`高速缓存`.

高速缓存: 一份数据拷贝,速度快,内存小.

程序执行过程也就变成了:高速缓存会将计算用的数据拷贝一份,CPU直接从高速缓存获取数据.计算后向缓存插入数据,缓存内的数据再写入主存.

随着CPU速度的进一步提升,高速缓存也从原来的一层衍生为`多级缓存`.

多级缓存:按照数据读取顺序和CPU结合的紧密程度,分为`一级缓存(L1),二级缓存(L2).....`.每一级缓存中所存储的全部数据都是下一级缓存的一部分.

加入多级缓存以后,自然程序执行的时候就变成了,CPU从L1查询数据,无数据查询L2,逐级往下查询的模式.

众所周知,CPU是有单核和多核之分.在单核CPU的时候,只需要一套L1,L2,L3缓存.但是当多核时,每个核心都必须有自己的一套L1(甚至L2)缓存,而共享L3(或L2)缓存.

![CPU高速缓存](/postImg/JMM/JMM01.jpg)

随着计算机能力的更进一步发展,从单线程,变成了多线程.这时候问题出现了.下面我们分析一下单线程,多线程单核,多核的情况.

+ 单线程:CPU核心的缓存只有一个线程访问.缓存独占,不会出现数据访问冲突,数据不一致等问题.
+ 单核CPU,多线程:进程中多线程同时访问缓存,获取的缓存地址相同,不会出现缓存丢失等问题,但是会出现,多线程同时操作同一缓存数据导致数据错误的情况.(CPU处理非原子性,多线程互相争抢运行,会出现处理一半共享数据被其他线程更新的情况-->并发)
+ 多核CPU,多线程:L3(共享缓存)情况如同单核多线程.单由于每个核心都有自己的L1/L2,线程运行多核切换,多核内的缓存数据不一致.

也就是说,在多线程的情况下.缓存会出现`缓存一致性问题`
![CPU高速缓存](/postImg/JMM/JMM02.jpg)

学过JVM的亲们应该都知道,JVM的JAVA即时编译器(JIT)会做`指令重排`来提升性能.计算机硬件也有类似的功能-->`处理器优化`.
处理器优化会把指令重排,也就是执行的顺序不会按照我们代码编写顺序,而且乱序的.那么在并发编程的情况下,这就会导致数据处理和判断错误,得到不是我们希望的结果.

那么我们怎么处理这些问题呢

铛铛铛 --> 主角  内存模型出场

#### 什么是内存模型
`内存模型`: 为了保证共享内存的正确性（可见性、有序性、原子性），内存模型`定义了共享内存系统中多线程程序读写操作行为的规范`.

本文主要讲解java内存模型,如果对内存模型的相关内容有兴趣,下篇 -->内存模型详解马上推出哦 对就是骗你关注.


### JAVA内存模型
真正的主角登场了 JAVA内存模型 Java Memory Model (JMM) (本文为JDK5开始使用的内存模型)

JMM规定了所有的变量都存储在主内存中(类似计算机内存吧),每条线程都有自己的工作内存(像不像高速缓存),线程中的工作内存中保存了该线程中用到的变量(主内存中的拷贝).线程对变量的所有操作都在工作内存中进行.线程之间工作内存不可互通.数据传递依靠主内存.

JMM规定了,工作内存和主存之间
多线程运行的时候就类似于一个单核多线程的CPU有没有.











主存 -> 计算器物理内存

CPU -> 高速缓存 -> 内存

而随着CPU能力的不断提升，一层缓存就慢慢的无法满足要求了，就逐渐的衍生出多级缓存

按照数据读取顺序和与CPU结合的紧密程度，CPU缓存可以分为一级缓存（L1），二级缓存（L3），部分高端CPU还具有三级缓存（L3），每一级缓存中所储存的全部数据都是下一级缓存的一部分。

当CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找。

处理器可能会对输入代码进行乱序执行处理。这就是处理器优化。

除了现在很多流行的处理器会对代码进行优化乱序处理，很多编程语言的编译器也会有类似的优化，比如Java虚拟机的即时编译器（JIT）也会做指令重排。



1.缓存数据一致性   可见性
2.处理器优化     原子性问题
3.指令重排  JIT java 即时编译器 有序性问题

为了保住 共享内存的正确性(可见性,有序性,原子性)，内存模型定义了共享内存系统中多线程程序读写操作行为的规范.

如何处理呢  （1.限制处理器优化  2 内存屏障） --- 》 后续文章

### 什么的java内存模型

https://www.jianshu.com/p/8420ade6ff76

https://cloud.tencent.com/developer/ask/220158

https://blog.csdn.net/Primitive_Heart/article/details/85088018

https://www.infoq.cn/article/java-memory-model-1



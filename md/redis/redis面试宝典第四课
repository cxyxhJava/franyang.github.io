# Redis面试宝典第四课
1. Redis线程模型
2. 为什么Redis的操作是原子性的,怎么保证原子性的？
3. Redis事务
4. Redis实现分布式锁

## Redis线程模型
`文件事件处理器`包括分别是`套接字`、 `I/O 多路复用程序`、 `文件事件分派器(dispatcher)`、 以及`事件处理器`.使用 I/O 多路复用程序来同时监听多个套接字, 并根据套接字目前执行的任务来为套接字关联不同的事件处理器.当被监听的套接字准备好执行连接应答(accept)、读取(read)、写入(write)、关闭(close)等操作时, 与操作相对应的文件事件就会产生, 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件.

I/O 多路复用程序负责监听多个套接字, 并向文件事件分派器传送那些产生了事件的套接字.工作原理：I/O 多路复用程序负责监听多个套接字, 并向文件事件分派器传送那些产生了事件的套接字.
尽管多个文件事件可能会并发地出现, 但 I/O 多路复用程序总是会将所有产生事件的套接字都入队到一个队列里面, 然后通过这个队列, 以有序(sequentially)、同步(synchronously)、每次一个套接字的方式向文件事件分派器传送套接字： 当上一个套接字产生的事件被处理完毕之后(该套接字为事件所关联的事件处理器执行完毕), I/O 多路复用程序才会继续向文件事件分派器传送下一个套接字.如果一个套接字又可读又可写的话, 那么服务器将先读套接字, 后写套接字.
[]()图片

## 为什么Redis的操作是原子性的,怎么保证原子性的？
对于Redis而言,命令的原子性指的是：一个操作的不可以再分,操作要么执行,要么不执行.

Redis的操作之所以是原子性的,是因为Redis是单线程的.

Redis本身提供的所有API都是原子操作,Redis中的事务其实是要保证批量操作的原子性.

## Redis事务
Redis事务功能是通过`MULTI、EXEC、DISCARD和WATCH1`四个原语实现的.

Redis会将一个事务中的所有命令序列化,然后按顺序执行.
1. redis 不支持回滚“Redis 在事务失败时不进行回滚,而是继续执行余下的命令”, 所以 Redis 的内部可以保持简单且快速.
2. 如果在一个事务中的命令出现错误,那么所有的命令都不会执行；
3. 如果在一个事务中出现运行错误,那么正确的命令会被执行.
注：redis的discard只是结束本次事务,正确命令造成的影响仍然存在.

1. MULTI命令用于开启一个事务,它总是返回OK. MULTI执行之后,客户端可以继续向服务器发送任意多条命令,这些命令不会立即被执行,而是被放到一个队列中,当EXEC命令被调用时,所有队列中的命令才会被执行.
2. EXEC：执行所有事务块内的命令.返回事务块内所有命令的返回值,按命令执行的先后顺序排列. 当操作被打断时,返回空值 nil .
3. 通过调用DISCARD,客户端可以清空事务队列,并放弃执行事务, 并且客户端会从事务状态中退出.
4. WATCH 命令可以为 Redis 事务提供 check-and-set (CAS)行为. 可以监控一个或多个键,一旦其中有一个键被修改(或删除),之后的事务就不会执行,监控一直持续到EXEC命令.

## Redis实现分布式锁

### 单机Redis/卡槽模式集群
Redis为单进程单线程模式,采用队列模式将并发访问变成串行访问,且多客户端对Redis的连接并不存在竞争关系Redis中可以使用SETNX命令实现分布式锁.
将 key 的值设为 value ,当且仅当 key 不存在. 若给定的 key 已经存在,则 SETNX 不做任何动作

解锁：使用 del key 命令就能释放锁
解决死锁：
1. 通过Redis中expire()给锁设定最大持有时间,如果超过,则Redis来帮我们释放锁.
2. 使用 setnx key “当前系统时间+锁持有的时间”和getset key “当前系统时间+锁持有的时间”组合的命令就可以实现.

### 主从等其他集群模式下
使用`Redission`实现

详情见文章:


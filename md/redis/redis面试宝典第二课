# Redis面试宝典第二课
2. `MemCache`与`Redis`的区别都有哪些？
3. redis的数据类型,以及每种数据类型的使用场景
4. Redis 内部结构
5. 单线程的redis为什么这么快
6. Redis 为什么是单线程的,优点

## MemCache与Redis的区别都有哪些？
1. 存储方式 `MemCache`把数据全部存在内存之中,断电后会清除,数据不能超过内存大小. Redis有部份存在硬盘上,redis可以持久化其数据
2. 数据支持类型 `MemCache`所有的值均是简单的字符串,`redis`作为其替代者,支持更为丰富的数据类型 ,提供list,set,zset,hash等数据结构的存储
3. 使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样. Redis直接自己构建了VM 机制 ,因为一般的系统调用系统函数的话,会浪费一定的时间去移动和请求.
4. value 值大小不同:Redis 最大可以达到 512M；`MemCache` 只有 1mb.
5. redis的速度比`MemCache`快很多
6. Redis支持数据的备份,即master-slave模式的数据备份.

## redis的数据类型,以及每种数据类型的使用场景
1. String:最常规的set/get操作,value可以是String也可以是数字.一般做一些复杂的计数功能的缓存.
2. hash:这里value存放的是结构化的对象,比较方便的就是操作其中的某个字段,小哈在做单点登录的时候,就是用这种数据结构存储用户信息,以cookieId作为key,设置30分钟为缓存过期时间,能很好的模拟出类似session的效果.
3. list:使用List的数据结构,可以做简单的消息队列的功能,先进先出的原则.另外还有一个就是,可以利用lrange命令,做基于redis的分页功能,性能极佳,用户体验好.
4. set:因为set堆放的是一堆不重复值的集合.所以可以做全局去重的功能.为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署,使用JVM自带的Set,比较麻烦,难道为了一个做一个全局去重,再起一个公共服务,太麻烦了.另外,就是利用交集、并集、差集等操作,可以计算共同喜好,全部的喜好,自己独有的喜好等功能.
5. sorted set:sorted set多了一个权重参数`score`,集合中的元素能够按score进行排列.可以做排行榜应用,取TOP N操作.

## Redis 内部结构
+ `dict` 本质上是为了解决算法中的查找问题（Searching）是一个用于维护key和value映射关系的数据结构,与很多语言中的Map或dictionary类似. 本质上是为了解决算法中的查找问题（Searching）
+ `sds`:sds就等同于char * 它可以存储任意二进制数据,不能像C语言字符串那样以字符’\0’来标识字符串的结 束,因此它必然有个长度字段.
+ `skiplist（跳跃表）`:跳表是一种实现起来很简单,单层多指针的链表,它查找效率很高,堪比优化过的二叉平衡树,且比平衡树的实现.
+ `quicklist`
+ `ziplist(压缩表)`:ziplist是一个编码后的列表,是由一系列特殊编码的连续内存块组成的顺序型数据结构.
后续会加详细介绍文
https://blog.csdn.net/u010627840/article/details/82144523

## 单线程的redis为什么这么快
1. 纯内存操作:绝大部分请求是纯粹的内存操作（非常快速）
2. 采用单线程,避免了不必要的上下文切换和竞争条件
3. 采用了非阻塞I/O多路复用机制

非阻塞IO优点:
1. 速度快,因为数据存在内存中,类似于HashMap,HashMap的优势就是查找和操作的时间复杂度都是O(1)
2. 支持丰富数据类型,支持string,list,set,sorted set,hash
3. 支持事务,操作都是原子性,所谓的原子性就是对数据的更改要么全部执行,要么全部不执行
4. 丰富的特性:可用于缓存,消息,按key设置过期时间,过期后将会自动删除如何解决redis的并发竞争key问题

## Redis 为什么是单线程的
官方FAQ表示,因为Redis是基于内存的操作,CPU不是Redis的瓶颈,Redis的瓶颈最有可能是机器内存的大小或者网络带宽.既然单线程容易实现,而且CPU不会成为瓶颈,那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）Redis利用队列技术将并发访问变为串行访问
## Redis集群下Key访问的处理
不推荐使用redis的事务机制.因为我们的生产环境,基本都是redis集群环境,做了数据分片操作.你一个事务中有涉及到多个key操作的时候,这多个key不一定都存储在同一个redis-server上.因此,redis的事务机制,十分鸡肋.

1. 如果对这个key操作,不要求顺序:准备一个`分布式锁`,大家去抢锁,抢到锁就做set操作即可
2. 如果对这个key操作,要求顺序:`分布式锁+时间戳`. 假设这会系统B先抢到锁,将key1设置为{valueB 3:05}.接下来系统A抢到锁,发现自己的valueA的时间戳早于缓存中的时间戳,那就不做set操作了.以此类推.
3. 利用队列,将set方法变成串行访问也可以redis遇到高并发,如果保证读写key的一致性
对redis的操作都是具有原子性的,是线程安全的操作,你不用考虑并发问题,redis内部已经帮你处理好并发的问题了.


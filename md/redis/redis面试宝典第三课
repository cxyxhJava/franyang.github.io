# Redis面试宝典第三课
1. redis的过期策略以及内存淘汰机制
2. Redis 集群方案应该怎么做？都有哪些方案？
3. 有没有尝试进行多机redis 的部署？如何保证数据一致的？
4. 对于大量的请求怎么样处理
5. Redis 常见性能问题和解决方案？

## redis的过期策略以及内存淘汰机制
redis采用的是`定期删除+惰性删除策略`.

### 为什么不用定时删除策略?
`定时删除`:用一个定时器来负责监视key,过期则自动删除.虽然内存及时释放,但是十分消耗CPU资源.在大并发请求下,CPU要将时间应用在处理请求,而不是删除key,因此没有采用这一策略.

### 定期删除+惰性删除是如何工作的呢?
`定期删除`:redis默认每个`100ms`检查,是否有过期的key,有过期key则删除.需要说明的是,redis不是每个100ms将所有的key检查一次,而是随机抽取进行检查(如果每隔100ms,全部key进行检查,redis岂不是卡死).因此,如果只采用定期删除策略,会导致很多key到时间没有删除.于是,`惰性删除`派上用场.

`惰性删除`:也就是说在你获取某个key的时候,redis会检查一下,这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除.

### 采用定期删除+惰性删除就没其他问题了么?
不是的,如果定期删除没删除key.然后你也没即时去请求key,也就是说惰性删除也没生效.这样,redis的内存会越来越高.那么就应该采用`内存淘汰机制`.

在redis.conf中有一行配置
```
maxmemory-policy volatile-lru
```
该配置就是配内存淘汰策略的
+ volatile-lru:从已设置过期时间的数据集(server.db[i].expires)中挑选最近最少使用的数据淘汰
+ volatile-ttl:从已设置过期时间的数据集(server.db[i].expires)中挑选将要过期的数据淘汰
+ volatile-random:从已设置过期时间的数据集(server.db[i].expires)中任意选择数据淘汰
+ allkeys-lru:从数据集(server.db[i].dict)中挑选最近最少使用的数据淘汰
+ allkeys-random:从数据集(server.db[i].dict)中任意选择数据淘汰
+ no-enviction(驱逐):禁止驱逐数据,新写入操作会报错
```
ps:如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致.
```

## Redis 集群方案应该怎么做？都有哪些方案？
1. `twemproxy`:它类似于一个`代理方式`, 使用时在本需要连接 redis 的地方改为连接 twemproxy, 它会以一个代理的身份接收请求并使用一致性 hash 算法,将请求转接到具体 redis,将结果再返回 twemproxy.

缺点: twemproxy 自身单端口实例的压力,使用一致性 hash 后,对 redis 节点数量改变时候的计算值的改变,数据无法自动移动到新的节点.

2. `codis`:目前用的最多的集群方案,基本和 twemproxy 一致的效果,但它支持在 节点数量改变情况下,旧节点数据可恢复到新 hash 节点

3. redis cluster3.0 自带的集群,特点在于他的分布式算法不是一致性 hash,而是 hash 槽的概念,以及自身支持节点设置从节点.具体看官方文档介绍.

## 有没有尝试进行多机redis 的部署？如何保证数据一致的？
+ `主从复制`
+ `读写分离`

一类是主数据库(master)一类是从数据库(slave),主数据库可以进行读写操作,当发生写操作的时候自动将数据同步到从数据库,而从数据库一般是只读的,并接收主数据库同步过来的数据,一个主数据库可以有多个从数据库,而一个从数据库只能有一个主数据库.

## 对于大量的请求怎么样处理
redis是一个单线程程序,也就说同一时刻它只能处理一个客户端请求；
redis是通过`IO多路复用`(select,epoll, kqueue,依据不同的平台,采取不同的实现)来处理多个客户端请求的

## Redis 常见性能问题和解决方案？
1. Master 最好不要做任何持久化工作,如 RDB 内存快照和 AOF 日志文件
2. 如果数据比较重要,某个 Slave 开启 AOF 备份数据,策略设置为每秒同步一次
3. 为了主从复制的速度和连接的稳定性, Master 和 Slave 最好在同一个局域网内
4. 尽量避免在压力很大的主库上增加从库
5. 主从复制不要用图状结构,用单向链表结构更为稳定,即: Master <- Slave1 <- Slave2 <-
Slave3…
# Java线程的生命周期

## 前言
在Java领域实现并发的主要手段就是`多线程`.线程是操作系统的一个概念,线程也会"生老病死",这就叫`线程的生命周期`.各种不同的开发语言对操作系统线程进行了封装,但是基本大同小异,生命周期也是如此.下面我们来介绍一下通用的线程生命周期,和Java中的线程生命周期.

## 通用线程生命周期
通用线程生命周期,分为五种状态如图所示:
![通用线程生命周期](/resources/线程状态.png)

通用的线程生命周期分为
+ 初始状态:线程创建(编程语言层面),操作系统层面还未创建线程,因此还不能分配CPU.
+ 可运行状态:CPU可以分配,但未分配,线程等待空闲CPU分配的状态.此时系统线程已创建.
+ 休眠状态:运行状态的线程被阻塞/等待,线程进入休眠状态释放CPU使用权,休眠状态不可分配CPU,需要先变回可运行状态.
+ 运行状态:可运行状态下空闲CPU分配后,实际在CPU内运行状态.
+ 终止状态:线程销毁.

互相的转换关系如上图所示,创建后先变成可运行状态等待CPU,随后分配到CPU后开始运行,这时候如果不发生阻塞/等待,直接运行完毕后销毁,不然进入休眠状态,阻塞/等待结束后,转变回可运行状态.

## Java线程生命周期
介绍完通用的线程生命周期,再来看看Java线程的生命周期.Java的生命周期也分为五种状态,如图所示:
![](/resources/java线程生命周期.jpg)

+ NEW(初始化状态)
+ RUNNABLE(可运行/就绪状态)
+ RUNNING(运行转态)
+ BLOCKED(阻塞状态)
+ TERMINATED(终止状态)
下面我们就来详细介绍各个状态,和状态间的装换.

### NEW(初始化状态)
NEW初始状态:线程刚刚被创建时候的状态.
我们看下面这段代码:
```
Thread thread = new Thread();
```
这就是java语言中线程创建的方式(创建线程对象).这时候小伙伴要问了,那我们的线程业务写在哪里呢?再看下面的代码:
```
    Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                //线程运行逻辑
            }
        });
```
下面就是我们创建一个,自定义线程运行逻辑的线程.在run()方法内书写你的线程业务逻辑.
```
  Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                //线程运行逻辑
            }
        });
```
再看下面这个代码
```
Thread thread = new Thread(()->{
            //线程业务逻辑
        }
        );
```
这就是使用`Java 8 Lambda 表达式`后的书写方式,是不是精简了很多.这就是我们要持续学习的原因,让代码更加的优秀和精明.

### RUNNABLE(可运行/就绪状态)
RUNNABLE(可运行/就绪状态):这是一个中间状态,在线程创建后,进入运行状态前,线程需要等待资源(类似操作系统线程等CPU),这时候的状态就是RUNNABLE(可运行/就绪状态).

以下代码就是进入运行状态的代码.
```
thread.start();
```
这里要特别注意,很多人都会听说创建线程有三种方式
1. 创建Thread对象
2. 实现Runnable接口
3. 实现Callable接口
这其中,2.3方式只是写线程实现,时间创建线程只有方式1,最后必须调用`thread.start()`才能创建运行线程,2,3方式的`run()`方法只是在当前主线程中运行方法而已,初学者特别注意.

## RUNNING(运行转态)
RUNNING(运行转态):调用`start()`方法后,线程分配到资源,开始执行(对于编程语言来说的运行,实际在CPU的运行还是需要等待操作系统的线程分配).

## BLOCKED(阻塞状态)
BLOCKED(阻塞状态):线程不可以获取资源,需要等待阻塞时间结束后再转换为就绪状态去获取资源.
BLOCKED(阻塞状态)又可以分为`WAITING(无时限等待)`和`TIMED_WAITING(有时限等待)`.这两种状态的区别就是,是否设置时限,`WAITING(无时限等待)`会一直阻塞知道主动调用取消阻塞/阻塞事件结束,而`TIMED_WAITING(有时限等待)`会设置阻塞时间,当时间到达后会自动取消阻塞,不管阻塞事件是否接收.

变成阻塞转态的原因有:
+ `synchronized`关键字
+ 等待队列(本是Object里的方法,但影响了线程)

synchronized详解查看文章
synchronized实例查看文章
等待队列详解查看文章

## TERMINATED(终止状态)
线程进入了Terminated状态,就意味着这个线程生命的终结.线程已经死亡不可再调用.JVM回收线程对象内存.那么什么时候会进入终止状态呢？
+ 线程正常运行结束,生命周期正常结束.
+ 线程运行过程中出现意外错误.系统异常结束(此时系统异常,如果不捕获异常,异常传播到主线程,主线程也会被异常停止).


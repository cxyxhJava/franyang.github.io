# 锁系列精讲-->初始锁

## 锁分类

Java提供了种类丰富的锁,每种锁因其特性的不同,在适当的场景下能够展现出非常高的效率.本位会介绍Java中出现的一些锁的基本概念.如图所示:
![](/resources/lock/lock总览.jpg)
### `公平锁`和`非公平锁`

+ 公平锁:多个线程按照申请锁的`顺序获取锁`.
+ 非公平锁:`非顺序获取锁`,多个线程获取锁的顺序并不是按照申请锁的顺序、有可能后申请的先获取到锁、或造成优先级反转或者锁饥饿现象.

### `独占锁`和`共享锁`

+ 独占锁:该锁每一次只能有`一个线程持有`,如`ReentrantLock`
+ 共享锁:该锁可以被`多个线程共有`.典型的就是`ReentrantReadWriteLock`里的`读写锁`,它的`读锁是可重入锁`、`写锁为独占锁`.

### `可重入锁`和`非可重入锁`
+ 可重入锁:又称`递归锁`,可以多层获取锁,在外层申请到锁后,内层仍可以使用锁并不会发生`死锁`（前提是同一个对象或者Class）这种锁被称为`可重入锁`.如 `ReentrantLock`、`synchronized`等
+ 非可重入锁:和可重入锁相反,不可递归调用,递归调用会发生死锁.

### `乐观锁` 和 `悲观锁`

`乐观锁`与`悲观锁`是一种广义上的概念,体现了看待线程同步的不同角度.在`Java`和`数据库`中都有此概念对应的实际应用.

+ 悲观锁:对于同一个数据的`并发操作`,悲观锁认为自己在使用数据的时候一定有别的线程来修改数据,因此在获取数据的时候会先加锁,确保数据不会被别的线程修改.Java中,`synchronized`关键字和`Lock`的实现类都是悲观锁.

+ `乐观锁`:认为自己在使用数据时不会有别的线程修改数据,所以不会添加锁,只是在更新数据的时候去判断之前有没有别的线程更新了这个数据.如果这个数据没有被更新,当前线程将自己修改的数据成功写入.如果数据已经被其他线程更新,则根据不同的实现方式执行不同的操作（例如报错或者自动重试）.乐观锁在Java中是通过使用`无锁编程`来实现,最常采用的是`CAS算法`,Java原子类中的递增操作就通过CAS自旋实现的.

### `分段锁`
+ 分段锁其实是`一种锁的设计思想`,他并不是一种锁.典型的实现就是`ConcurrentHashMap`,其并发操作就是使用分段锁来设计实现的以达到高效的并发操作.

### `自旋锁`

+ 自旋锁:也就是一个线程在获取锁时发现此锁已被其它线程持有,它就会循环等待不断的判断锁是否可以成功获取,直到成功获取锁才退出循环.（说白了也就把获取锁的逻辑放到一个无限循环中,退出条件就是获取到锁）
### `偏向锁`
+ 偏向锁:如果一个同步代码块一直被同一个线程使用访问,那么该线程会自动获取锁,降低获取锁的代价(可以更优先获取到锁)

### `轻量锁`和`重量级锁`
+ 轻量锁:`当锁为偏向锁时`共享资源被另一个线程访问,这时偏向锁会升级为轻量级锁.其它线程会通过自旋的形式来获取锁（不会阻塞,提高性能）.

+ 重量级锁:`当锁为轻量级锁时`,另一个线程虽然会通过自旋来获取锁但是不会无休止的自旋下去当自旋到一定次数或者时间时就会阻塞,这时轻量级锁就会膨胀为重量级锁.重量级锁会让线程阻塞,效率极低.
